Yes ‚Äî adding a new Kubernetes Cloud dynamically to Jenkins using a RESTful API is possible, but there are a few nuances depending on what you want exactly (e.g., add via Jenkins Script Console, plugin extension, or external API endpoint). Let‚Äôs go over the main approaches.

üí° 1. Understanding the Context

When you use the Kubernetes plugin
, the ‚Äúcloud‚Äù you configure under Manage Jenkins ‚Üí Clouds is stored in Jenkins‚Äô internal configuration as a KubernetesCloud object.

Programmatically, this object is represented by:

org.csanchez.jenkins.plugins.kubernetes.KubernetesCloud


So, adding one dynamically means you want to do something equivalent to:

Manually clicking ‚ÄúAdd a new cloud‚Äù in the UI,

But done through a REST API call or code.

üß© 2. Approach Options
Option A ‚Äì Use Jenkins Script Console or REST API (Groovy Script)

You can POST Groovy code to the Jenkins Script API (/scriptText) or use the Script Console.
Here‚Äôs a working example Groovy script to create a Kubernetes cloud dynamically:

import org.csanchez.jenkins.plugins.kubernetes.*

def cloudName = "my-k8s-cloud"
def serverUrl = "https://your-k8s-api-server"
def namespace = "jenkins"
def credentialsId = "k8s-cred-id" // preconfigured in Jenkins credentials

// Check if cloud already exists
def existing = Jenkins.instance.clouds.find { it.name == cloudName }
if (existing != null) {
    println "Cloud '${cloudName}' already exists"
    return
}

// Create new Kubernetes cloud
def cloud = new KubernetesCloud(
    cloudName,
    null,
    serverUrl,
    namespace,
    credentialsId,
    null,
    0, 0, 0
)

// Optional: configure pod templates
def podTemplate = new PodTemplate()
podTemplate.setName("default-pod")
podTemplate.setNamespace(namespace)
podTemplate.setLabel("jenkins-agent")
podTemplate.setServiceAccount("default")

cloud.addTemplate(podTemplate)

// Add to Jenkins
Jenkins.instance.clouds.add(cloud)
Jenkins.instance.save()

println "Added Kubernetes cloud '${cloudName}' successfully."


You can send this via REST API:

curl -X POST \
  -u admin:token \
  --data-urlencode "script=$(< add-k8s-cloud.groovy)" \
  http://jenkins.yourdomain.com/scriptText


‚úÖ Pros:

Works with existing Jenkins APIs.

No plugin changes needed.

Can be automated from external systems.

‚ö†Ô∏è Cons:

Requires Script Console or /scriptText access (admin-level).

Not suitable for end-user safe APIs unless sandboxed.

Option B ‚Äì Implement a Jenkins Plugin with a REST Endpoint

If you want a dedicated REST API endpoint (e.g. /k8sCloud/add), you can implement a Jenkins plugin that exposes it via the Stapler or REST API layer.

Example (simplified):

package io.mycompany.jenkins.k8sapi;

import hudson.Extension;
import hudson.model.UnprotectedRootAction;
import org.csanchez.jenkins.plugins.kubernetes.KubernetesCloud;
import jenkins.model.Jenkins;

import javax.servlet.ServletException;
import java.io.IOException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Extension
public class K8sCloudAPI implements UnprotectedRootAction {
    @Override
    public String getIconFileName() { return null; }
    @Override
    public String getDisplayName() { return null; }
    @Override
    public String getUrlName() { return "k8sCloud"; }

    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse rsp) throws ServletException, IOException {
        String name = req.getParameter("name");
        String serverUrl = req.getParameter("serverUrl");
        String namespace = req.getParameter("namespace");
        String credentialsId = req.getParameter("credentialsId");

        KubernetesCloud cloud = new KubernetesCloud(
            name, null, serverUrl, namespace, credentialsId, null, 0, 0, 0
        );

        Jenkins j = Jenkins.get();
        j.clouds.add(cloud);
        j.save();

        rsp.setStatus(HttpServletResponse.SC_OK);
        rsp.getWriter().println("Cloud added: " + name);
    }
}


‚úÖ Pros:

Clean REST API endpoint.

Controlled permissions.

Integrates with Jenkins permission model.

‚ö†Ô∏è Cons:

Requires custom plugin development and deployment.

Must handle auth and validation carefully.

Option C ‚Äì Use Configuration-as-Code (JCasC) Reload via REST

If you are using Jenkins Configuration as Code (JCasC)
, you can define clouds declaratively in YAML:

jenkins:
  clouds:
    - kubernetes:
        name: "my-k8s-cloud"
        serverUrl: "https://your-k8s-api-server"
        namespace: "jenkins"
        credentialsId: "k8s-cred-id"


Then, via REST or CLI, you can trigger a reload of JCasC configuration to apply the new cloud.
This is the safest for GitOps-style management, but not ‚Äúadd cloud dynamically‚Äù per se ‚Äî it‚Äôs declarative.

üß≠ 3. Recommended Strategy

If you want:

Fast automation (admin-controlled): ‚Üí Use Option A (Groovy via REST)

Public API for users: ‚Üí Use Option B (Custom plugin)

GitOps-style config: ‚Üí Use Option C (JCasC YAML reload)

Would you like me to show you a real implementation of Option B (custom plugin with REST endpoint for adding Kubernetes Cloud)?
I can generate the Java code, Jelly config, and plugin manifest (plugin.xml) for you.

You said:
with python requests, how to do it? should be restful api
ChatGPT said:

Perfect ‚Äî yes, you can absolutely add a Jenkins Kubernetes Cloud via a RESTful API call using Python‚Äôs requests library ‚Äî as long as you use Jenkins‚Äôs built-in /scriptText endpoint to run Groovy scripts remotely.

Jenkins doesn‚Äôt have a native REST API to ‚Äúcreate a cloud‚Äù (since that lives in its internal model), so the official way to do it via HTTP is to POST a Groovy script that constructs the KubernetesCloud object ‚Äî which effectively acts as your REST call.

Let‚Äôs walk through it üëá

‚úÖ Step-by-Step: Add a Kubernetes Cloud via REST API using Python
1. Requirements

Jenkins user with Admin or Script Console permission.

A Jenkins API token (recommended instead of password).

The Kubernetes plugin already installed.

2. The Groovy script (to send as payload)

This Groovy code creates the Kubernetes cloud inside Jenkins:

import org.csanchez.jenkins.plugins.kubernetes.*
import jenkins.model.Jenkins

def cloudName = "my-k8s-cloud"
def serverUrl = "https://your-k8s-api-server"
def namespace = "jenkins"
def credentialsId = "k8s-cred-id" // must already exist

def j = Jenkins.instance

if (j.clouds.find { it.name == cloudName }) {
    println("Cloud '${cloudName}' already exists.")
    return
}

def cloud = new KubernetesCloud(
    cloudName,
    null,
    serverUrl,
    namespace,
    credentialsId,
    null,
    0, 0, 0
)

def podTemplate = new PodTemplate()
podTemplate.setName("default-agent")
podTemplate.setNamespace(namespace)
podTemplate.setLabel("jenkins-agent")
cloud.addTemplate(podTemplate)

j.clouds.add(cloud)
j.save()

println("‚úÖ Added cloud '${cloudName}' successfully.")

3. Python code using requests
import requests

# Jenkins base URL and credentials
jenkins_url = "http://jenkins.example.com"
user = "admin"
token = "your_api_token"

# The Groovy script you want Jenkins to run
groovy_script = """
import org.csanchez.jenkins.plugins.kubernetes.*
import jenkins.model.Jenkins

def cloudName = "my-k8s-cloud"
def serverUrl = "https://your-k8s-api-server"
def namespace = "jenkins"
def credentialsId = "k8s-cred-id"

def j = Jenkins.instance

if (j.clouds.find { it.name == cloudName }) {
    println("Cloud '${cloudName}' already exists.")
    return
}

def cloud = new KubernetesCloud(
    cloudName,
    null,
    serverUrl,
    namespace,
    credentialsId,
    null,
    0, 0, 0
)

def podTemplate = new PodTemplate()
podTemplate.setName("default-agent")
podTemplate.setNamespace(namespace)
podTemplate.setLabel("jenkins-agent")
cloud.addTemplate(podTemplate)

j.clouds.add(cloud)
j.save()

println("‚úÖ Added cloud '${cloudName}' successfully.")
"""

# Jenkins Script API endpoint
url = f"{jenkins_url}/scriptText"

# POST the script to Jenkins
response = requests.post(
    url,
    auth=(user, token),
    data={"script": groovy_script},
    verify=False  # optional if you use self-signed SSL
)

# Print Jenkins output
print(response.text)

4. Output Example

If successful, Jenkins will return something like:

‚úÖ Added cloud 'my-k8s-cloud' successfully.


If the cloud already exists:

Cloud 'my-k8s-cloud' already exists.


If something is wrong (like missing credentials or plugin not installed), Jenkins will print the stack trace in the response text ‚Äî so check response.text carefully.

5. Security Notes

This requires admin privileges.

The /scriptText endpoint is powerful (can execute any Groovy code).

If you need a restricted REST API (for normal users), you‚Äôd need to implement a custom Jenkins plugin endpoint (as I mentioned before).

Would you like me to show you a version that can update (or delete) the cloud if it already exists ‚Äî still via Python + REST API? That‚Äôs often useful for automation or GitOps-like workflows.

You said:
i checked with edge devtool and found that when create a cloud, it will send the post request to /cloud/docreate. can we emiluate it?
ChatGPT said:

Excellent observation üîç ‚Äî you‚Äôre right!
When you click ‚ÄúAdd a new cloud‚Äù in Jenkins UI and hit Save, your browser sends a form submission (POST) to:

/jenkins/cloud/doCreate


This is technically the endpoint that creates a cloud ‚Äî but there‚Äôs a big catch: it‚Äôs not a public or stable REST API, it‚Äôs a Stapler form submission endpoint (the internal Jenkins web framework).

That means you can emulate it with requests, but you must:

Reproduce the exact form field names,

Include Jenkins‚Äô CSRF crumb,

Include a valid session or API token authentication.

Let‚Äôs go step-by-step üëá

üß© 1. What /cloud/doCreate Actually Does

URL: POST /jenkins/cloud/doCreate

Type: multipart/form-data or application/x-www-form-urlencoded

Purpose: Trigger Jenkins‚Äô form-binding code to create a new KubernetesCloud object via the standard Descriptor.newInstance path.

It‚Äôs equivalent to hitting ‚ÄúSave‚Äù in the ‚ÄúConfigure System‚Äù page for Clouds.

‚öôÔ∏è 2. How to Emulate It with requests

Below is a Python script that mimics the UI request.

import requests

jenkins_url = "http://jenkins.example.com"
user = "admin"
token = "your_api_token"

session = requests.Session()
session.auth = (user, token)

# 1Ô∏è‚É£ Get CSRF crumb (needed if CSRF protection is enabled)
crumb_response = session.get(f"{jenkins_url}/crumbIssuer/api/json")
crumb_data = crumb_response.json()
session.headers.update({crumb_data['crumbRequestField']: crumb_data['crumb']})

# 2Ô∏è‚É£ Prepare POST data ‚Äî these fields must match Jenkins‚Äô expected form parameters
payload = {
    "stapler-class": "org.csanchez.jenkins.plugins.kubernetes.KubernetesCloud",
    "name": "my-k8s-cloud",
    "serverUrl": "https://your-k8s-api-server",
    "namespace": "jenkins",
    "credentialsId": "k8s-cred-id",
    "skipTlsVerify": "false",
    "jenkinsUrl": "",
    "jenkinsTunnel": "",
    "connectTimeout": "0",
    "readTimeout": "0",
    "containerCapStr": "10",
    "maxRequestsPerHostStr": "32",
    "retentionTimeout": "5",
    "usageRestricted": "false",
    "stapler-class-bag": "true",
    "_.add": ""  # necessary when no templates defined
}

# 3Ô∏è‚É£ Send POST to create the cloud
resp = session.post(f"{jenkins_url}/cloud/doCreate", data=payload, allow_redirects=False)

print("Status:", resp.status_code)
print("Response:", resp.text)

üß† 3. How It Works

Jenkins internally maps /cloud/doCreate ‚Üí hudson.model.Cloud.doCreate() in core,
which uses the Descriptor.newInstance(StaplerRequest, JSONObject) mechanism.
So as long as your POST data includes:

stapler-class (the full Java class name of the cloud)

The correct form field names (matching the Jelly/Stapler descriptors)

Valid crumb/authentication

‚Ä¶Jenkins will instantiate your KubernetesCloud and persist it.

‚ö†Ô∏è 4. Limitations
‚ö†Ô∏è Issue	Explanation
Not official REST API	Internal endpoint ‚Äî Jenkins may change form field names anytime.
Needs CSRF crumb	Required if CSRF protection is on (default).
Hard to add Pod Templates	Complex nested objects (PodTemplate) require special json form encoding used by Stapler.
Difficult to debug	Jenkins doesn‚Äôt return structured JSON; only redirects or HTML error pages.
‚úÖ 5. When Is It Reasonable to Use

This trick is fine for:

Internal automation or bootstrapping Jenkins.

Scripts that mimic UI operations for setup.

But for production automation, using:

/scriptText (Groovy)
or

Configuration-as-Code (JCasC)

is more stable and supported.

If you want, I can:

‚úÖ Capture and explain the exact form fields that /cloud/doCreate expects for the Kubernetes plugin,

Or show a Python version that includes a Pod Template in the POST payload (which uses nested JSON field encoding Jenkins expects).

Would you like me to show that full payload example (with Pod Template included)?

You said:
for my case, i don't need the pod template. i would like to know if using jcasc, how to use the restful to implement it?
ChatGPT said:

Excellent ‚Äî you‚Äôre thinking in the right direction üëè

If your goal is to manage Jenkins Kubernetes Clouds dynamically via REST, but without using the internal /scriptText or /cloud/doCreate endpoints, then the Configuration-as-Code (JCasC) approach is the clean, supported, GitOps-friendly way to do it.

Let‚Äôs go over how to do this ‚Äî entirely with REST API calls using Python + requests.

‚öôÔ∏è 1. Prerequisites

Make sure you have:

The Configuration as Code plugin (configuration-as-code) installed.

The Kubernetes plugin installed.

Jenkins is running with admin credentials or API token access.

üß© 2. JCasC Endpoint Overview

JCasC exposes REST endpoints under /configuration-as-code/:

Endpoint	Method	Description
/configuration-as-code/view	GET	View current config as YAML
/configuration-as-code/export	GET	Export full current config
/configuration-as-code/reload	POST	Reload from source (usually file)
/configuration-as-code/apply	POST	Apply YAML config directly (üí• dynamic)

üëâ The one you need is POST /configuration-as-code/apply.

This lets you send YAML that defines a new cloud (e.g. KubernetesCloud) and Jenkins applies it instantly.

üßæ 3. Example JCasC YAML (Cloud only)

Here‚Äôs a minimal YAML to define a Kubernetes cloud without PodTemplates:

jenkins:
  clouds:
    - kubernetes:
        name: "my-k8s-cloud"
        serverUrl: "https://your-k8s-api-server"
        namespace: "jenkins"
        credentialsId: "k8s-cred-id"
        skipTlsVerify: false
        containerCapStr: "10"
        retentionTimeout: 5

üêç 4. Python requests example

Here‚Äôs how to POST it to Jenkins programmatically:

import requests
import yaml

jenkins_url = "http://jenkins.example.com"
user = "admin"
token = "your_api_token"

session = requests.Session()
session.auth = (user, token)

# Get CSRF crumb
crumb = session.get(f"{jenkins_url}/crumbIssuer/api/json").json()
session.headers.update({crumb["crumbRequestField"]: crumb["crumb"]})

# The JCasC YAML configuration
jcasc_yaml = """
jenkins:
  clouds:
    - kubernetes:
        name: "my-k8s-cloud"
        serverUrl: "https://your-k8s-api-server"
        namespace: "jenkins"
        credentialsId: "k8s-cred-id"
        skipTlsVerify: false
        containerCapStr: "10"
        retentionTimeout: 5
"""

# Send to JCasC apply endpoint
resp = session.post(
    f"{jenkins_url}/configuration-as-code/apply",
    headers={"Content-Type": "application/x-yaml"},
    data=jcasc_yaml.encode("utf-8"),
)

print("Status:", resp.status_code)
print("Response:", resp.text)

‚úÖ 5. If Successful

Jenkins will respond with:

Configuration applied successfully


and you‚Äôll see the new Kubernetes Cloud under
Manage Jenkins ‚Üí Clouds immediately.

‚ö†Ô∏è 6. Notes and Tips
Case	Explanation
Idempotency	JCasC will replace the existing jenkins.clouds list, not append by default. So if you have multiple clouds, include all of them in the YAML you send.
Credentials	The credentialsId must already exist in Jenkins.
Reapply safely	You can first call /configuration-as-code/export to get current YAML, append yours, and then POST to /apply.
Security	Only Jenkins admins can use this API.
Persistence	The applied config is written into Jenkins‚Äô runtime config (and optionally to disk if configured). It‚Äôs not automatically stored in the original YAML file unless you manage that externally.
üß† 7. Recommended Workflow

If your goal is to manage this programmatically or via automation:

Goal	Recommended Action
GitOps-style (versioned config)	Store the JCasC YAML in Git and reload via /configuration-as-code/reload
Ad-hoc REST API automation	Use /configuration-as-code/apply like above
Declarative management	Use Flux / Argo CD to deploy Jenkins with JCasC YAML as part of your infrastructure code

Would you like me to show an idempotent version of the Python script ‚Äî one that:

Fetches the current config (/export),

Merges a new cloud definition if missing,

Then applies it back?

That would give you a truly ‚ÄúRESTful upsert‚Äù behavior for Jenkins clouds.

You said:
if i use api4jenkins, how to change the code? and if i need to add one cloud but there is some other cloud, how to change the code
ChatGPT said:

Perfect ‚Äî using api4jenkins
 is much cleaner and safer than raw requests calls because it wraps the Jenkins REST API and CSRF handling for you.

Let‚Äôs walk through both of your needs step-by-step:

‚úÖ Goal

Use api4jenkins Python library.

Add a new Kubernetes cloud via JCasC REST API (/configuration-as-code/apply).

Keep existing clouds (don‚Äôt overwrite them).

‚öôÔ∏è 1. Install the library
pip install api4jenkins pyyaml

üß© 2. How Jenkins JCasC treats clouds

When you POST YAML to /configuration-as-code/apply,
Jenkins replaces the entire jenkins.clouds list with what you provide.

So, to safely add a new cloud (and preserve existing ones),
you must first:

Fetch the current configuration via /configuration-as-code/export.

Parse the YAML.

Add your new cloud to the jenkins.clouds list (if it doesn‚Äôt already exist).

Re-apply the merged config.

üêç 3. Full working example with api4jenkins
from api4jenkins import Jenkins
import yaml

# Jenkins connection
jenkins_url = "http://jenkins.example.com"
user = "admin"
token = "your_api_token"

jenkins = Jenkins(jenkins_url, auth=(user, token))

# 1Ô∏è‚É£ Get current JCasC configuration
export_url = f"{jenkins_url}/configuration-as-code/export"
resp = jenkins.session.get(export_url)
resp.raise_for_status()
config = yaml.safe_load(resp.text)

# 2Ô∏è‚É£ Ensure structure exists
if "jenkins" not in config:
    config["jenkins"] = {}
if "clouds" not in config["jenkins"]:
    config["jenkins"]["clouds"] = []

# 3Ô∏è‚É£ Define the new cloud you want to add
new_cloud = {
    "kubernetes": {
        "name": "my-new-k8s-cloud",
        "serverUrl": "https://your-k8s-api-server",
        "namespace": "jenkins",
        "credentialsId": "k8s-cred-id",
        "skipTlsVerify": False,
        "containerCapStr": "10",
        "retentionTimeout": 5
    }
}

# 4Ô∏è‚É£ Check if this cloud already exists (by name)
existing_clouds = config["jenkins"]["clouds"]
cloud_names = [
    c.get("kubernetes", {}).get("name")
    for c in existing_clouds
    if "kubernetes" in c
]

if new_cloud["kubernetes"]["name"] not in cloud_names:
    existing_clouds.append(new_cloud)
    print(f"Added new cloud: {new_cloud['kubernetes']['name']}")
else:
    print(f"Cloud {new_cloud['kubernetes']['name']} already exists ‚Äî skipping")

# 5Ô∏è‚É£ Apply the updated configuration via JCasC
apply_url = f"{jenkins_url}/configuration-as-code/apply"
yaml_payload = yaml.dump(config, sort_keys=False)

resp = jenkins.session.post(
    apply_url,
    data=yaml_payload.encode("utf-8"),
    headers={"Content-Type": "application/x-yaml"},
)
resp.raise_for_status()

print("‚úÖ Configuration applied successfully")

üß† 4. What This Script Does
Step	Description
1	Fetches your current JCasC YAML config from /configuration-as-code/export.
2	Parses it safely into a Python dict.
3	Defines a new Kubernetes cloud (no PodTemplates).
4	Checks if the same cloud name already exists (idempotent).
5	Re-applies the merged YAML to Jenkins ‚Äî preserving other clouds.
‚öôÔ∏è 5. Example Result

If you had two existing clouds and added one new:

jenkins:
  clouds:
    - kubernetes:
        name: "old-cloud"
        ...
    - kubernetes:
        name: "staging-cloud"
        ...
    - kubernetes:
        name: "my-new-k8s-cloud"
        serverUrl: "https://your-k8s-api-server"
        namespace: "jenkins"
        credentialsId: "k8s-cred-id"
        skipTlsVerify: false
        containerCapStr: "10"
        retentionTimeout: 5


All clouds remain intact üëå

‚ö†Ô∏è 6. Tips

api4jenkins handles auth and CSRF crumb automatically.

Use jenkins.session for custom REST calls not directly wrapped by the library.

You can use the same method to modify credentials, nodes, etc. via JCasC.

Would you like me to extend this example so that it can also update a cloud (e.g., if serverUrl or credentialsId changes)?
That would make it a fully idempotent upsert REST automation.

You said:
if using api4jenkins to implment the approach about /cloud/doCreate. how to do it
ChatGPT said:

Excellent ‚Äî now you‚Äôre asking how to use api4jenkins to emulate the UI‚Äôs /cloud/doCreate endpoint ‚Äî i.e. directly creating a Jenkins Kubernetes Cloud as if you clicked ‚ÄúAdd Cloud‚Äù in the UI, rather than via JCasC.

That‚Äôs totally possible ‚Äî but since /cloud/doCreate isn‚Äôt part of Jenkins‚Äô official REST API, you‚Äôll need to use the jenkins.session object from api4jenkins to manually post the correct form fields (just like you‚Äôd do with requests).

The benefit is:
‚úÖ You still get authentication + crumb handling automatically from api4jenkins.

Let‚Äôs walk through a working version.

üß© Background: /cloud/doCreate

Endpoint: POST /jenkins/cloud/doCreate

Expected form field:

stapler-class: full class name of the cloud implementation

other fields (name, serverUrl, namespace, etc.) are form-bound

Response: 302 redirect (success) or HTML error.

So we‚Äôll replicate that form post.

‚úÖ Python code using api4jenkins
from api4jenkins import Jenkins

jenkins_url = "http://jenkins.example.com"
user = "admin"
token = "your_api_token"

# Connect to Jenkins (handles auth + crumb)
jenkins = Jenkins(jenkins_url, auth=(user, token))

# Define form fields for the Kubernetes cloud
data = {
    "stapler-class": "org.csanchez.jenkins.plugins.kubernetes.KubernetesCloud",
    "name": "my-k8s-cloud",
    "serverUrl": "https://your-k8s-api-server",
    "namespace": "jenkins",
    "credentialsId": "k8s-cred-id",
    "skipTlsVerify": "false",
    "jenkinsUrl": "",
    "jenkinsTunnel": "",
    "containerCapStr": "10",
    "maxRequestsPerHostStr": "32",
    "retentionTimeout": "5",
    "usageRestricted": "false",
    "stapler-class-bag": "true",
    "_.add": "",  # needed if no pod templates are provided
}

# POST to the /cloud/doCreate endpoint
resp = jenkins.session.post(f"{jenkins_url}/cloud/doCreate", data=data, allow_redirects=False)

print("Status:", resp.status_code)
print("Location:", resp.headers.get("Location"))
print("Response snippet:", resp.text[:300])